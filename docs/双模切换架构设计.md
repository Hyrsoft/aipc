# 双模切换架构设计文档

## 概述

本文档描述了 AIPC 项目中引入的"双模切换"架构，允许系统在两种工作模式之间动态切换：

- **Mode A: Pure IPC (Parallel)** - 纯 IPC 并行模式，零拷贝硬件绑定
- **Mode B: Inference AI (Serial)** - AI 推理串行模式，软件控制帧流

## 架构对比

### Mode A: Pure IPC (Parallel)

```
VI ──硬件绑定──> VPSS ──硬件绑定──> VENC ──> 流分发
                   │
                   └──> Chn1 (可选 AI 帧获取)
```

**特点：**
- VI → VPSS → VENC 完全硬件绑定
- 零拷贝，CPU 几乎不参与数据流
- 最高帧率和最低延迟
- 总线压力最大（多模块并行访问 DDR）
- 适合：**无 AI 推理的纯流媒体场景**

### Mode B: Inference AI (Serial)

```
VI ──硬件绑定──> VPSS ──手动获取──> [AI 推理 + OSD] ──手动发送──> VENC ──> 流分发
```

**特点：**
- VI → VPSS 保持硬件绑定
- VPSS → VENC 解绑，由软件控制帧流动时序
- 每帧经过 CPU 处理（NV12→RGB、AI 推理、OSD 叠加）
- 总线压力分散（串行执行）
- 适合：**需要 AI 推理和 OSD 叠加的场景**

## 核心组件

### 1. 模式定义 (pipeline_mode.h)

```cpp
namespace rkvideo {

enum class PipelineMode {
    PureIPC,      // 并行模式
    InferenceAI   // 串行模式
};

// 串行模式帧处理回调类型
using FrameProcessCallback = std::function<bool(const RawFrame&, ProcessedFrame&)>;

}
```

### 2. 串行管道 (serial_pipeline.h/cpp)

负责 Mode B 的帧处理循环：

```cpp
class SerialPipeline {
public:
    int Init(const SerialPipelineConfig& config);
    int Deinit();
    bool Start(FrameProcessCallback callback);
    void Stop();
    void RegisterStreamConsumer(...);
};
```

核心流程：
1. 从 VPSS Chn0 手动获取 NV12 帧
2. 调用用户回调进行处理（转换 + 推理 + OSD）
3. 将 RGB 帧手动发送到 VENC
4. 获取编码结果并分发给消费者

### 3. 管道管理器 (pipeline_manager.h/cpp)

统一管理双模切换：

```cpp
class PipelineManager {
public:
    static PipelineManager& Instance();
    
    int Init(const PipelineManagerConfig& config);
    int Deinit();
    bool Start();
    void Stop();
    
    // 核心：模式切换（冷启动）
    int SwitchMode(PipelineMode mode, FrameProcessCallback callback = nullptr);
    
    // 流消费者会在模式切换后自动重新注册
    void RegisterStreamConsumer(...);
};
```

### 4. 串行帧处理器 (serial_frame_processor.h/cpp)

封装 AI 推理 + OSD 叠加逻辑：

```cpp
class SerialFrameProcessor {
public:
    static SerialFrameProcessor& Instance();
    
    bool Init(const SerialProcessorConfig& config);
    
    // 获取可传递给 SwitchMode 的回调函数
    FrameProcessCallback GetProcessCallback();
    
    std::vector<DetectionResult> GetLatestResults();
};
```

## 使用方法

### 基本用法

```cpp
#include "rkvideo/pipeline_manager.h"
#include "rknn/serial_frame_processor.h"

int main() {
    // 1. 初始化管道管理器（默认为并行模式）
    rkvideo::PipelineManagerConfig config;
    config.width = 1920;
    config.height = 1080;
    config.initial_mode = rkvideo::PipelineMode::PureIPC;
    
    rkvideo::PipelineManager::Instance().Init(config);
    
    // 2. 注册流消费者
    rkvideo::PipelineManager::Instance().RegisterStreamConsumer(
        "rtsp", rtsp_callback, ConsumerType::AsyncIO);
    
    // 3. 启动
    rkvideo::PipelineManager::Instance().Start();
    
    // ... 运行中 ...
    
    // 4. 切换到 AI 推理模式
    rknn::SerialFrameProcessor::Instance().Init();
    auto callback = rknn::SerialFrameProcessor::Instance().GetProcessCallback();
    
    rkvideo::PipelineManager::Instance().SwitchMode(
        rkvideo::PipelineMode::InferenceAI, callback);
    
    // ... AI 推理运行中 ...
    
    // 5. 切换回纯 IPC 模式
    rkvideo::PipelineManager::Instance().SwitchMode(
        rkvideo::PipelineMode::PureIPC);
    
    // 6. 清理
    rkvideo::PipelineManager::Instance().Deinit();
}
```

### HTTP API 控制

```bash
# 获取当前管道状态
curl http://device:8080/api/pipeline/status

# 切换到串行模式
curl -X POST http://device:8080/api/pipeline/switch \
     -H "Content-Type: application/json" \
     -d '{"mode": "serial"}'

# 切换回并行模式
curl -X POST http://device:8080/api/pipeline/switch \
     -H "Content-Type: application/json" \
     -d '{"mode": "parallel"}'
```

## 冷切换过程

模式切换时会执行以下步骤（约需 100-300ms）：

1. **Stop** - 停止当前帧处理循环
2. **Unbind** - 解除当前模式的 MPI 绑定
3. **Deinit** - 销毁 VENC/VPSS/VI
4. **Init** - 按新模式重新初始化 MPI
5. **Rebind** - 建立新的绑定关系
6. **Reregister** - 重新注册流消费者
7. **Start** - 启动新的帧处理循环

## 设计决策

### 为什么选择冷切换？

1. **确定性**：完全重建管道避免硬件状态残留问题
2. **简单性**：不需要处理动态绑定/解绑的边界条件
3. **安全性**：在嵌入式开发中，"能跑通"比"极致优化"更重要
4. **可预测**：冷启动时间可控，用户可预期

### 为什么保留两套逻辑？

1. **并行模式**：已验证稳定，零拷贝性能最优
2. **串行模式**：需要 OSD 叠加时必须使用，复用老架构逻辑
3. **灵活性**：用户可根据场景选择最适合的模式

## 文件结构

```
src/rkvideo/
├── pipeline_mode.h          # 模式定义和结构体
├── serial_pipeline.h        # 串行管道接口
├── serial_pipeline.cpp      # 串行管道实现
├── pipeline_manager.h       # 管道管理器接口
├── pipeline_manager.cpp     # 管道管理器实现
├── rkvideo.h                # 并行模式接口
├── rkvideo.cpp              # 并行模式实现
└── luckfox_mpi.h/cpp        # MPI 底层封装

src/rknn/
├── serial_frame_processor.h     # 串行帧处理器接口
├── serial_frame_processor.cpp   # 串行帧处理器实现
└── ...
```

## 后续优化方向

1. **热切换探索**：研究是否可以在不完全重建管道的情况下切换模式
2. **OSD 硬件加速**：使用 RGA 替代 OpenCV 绘制，减少 CPU 占用
3. **异步推理**：将 AI 推理放到独立线程，不阻塞编码流水线
4. **动态帧率**：AI 推理时自动降低编码帧率，平衡性能

## 参考

- [aipc_old](../aipc_old/) - 旧架构参考实现
- [Luckfox RKMPI 文档](https://wiki.luckfox.com/)
- [单核CPU优化重构](docs/单核CPU优化重构.md)
