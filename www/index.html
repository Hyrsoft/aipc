<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIPC - RV1106 è¾¹ç¼˜ AI ç›¸æœº</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        header p {
            color: #8892b0;
            font-size: 0.9rem;
        }

        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.05);
            padding: 5px;
            border-radius: 12px;
        }
        .tab-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            color: #8892b0;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .tab-btn:hover {
            color: #fff;
            background: rgba(255,255,255,0.05);
        }
        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* çŠ¶æ€æ  */
        .status-bar {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 12px 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .status-bar .status {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }
        .status-dot.offline {
            background: #ef4444;
            animation: none;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* æ§åˆ¶é¢æ¿å¡ç‰‡ */
        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .card h2 .icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .info-row:last-child {
            border-bottom: none;
        }
        .info-row .label {
            color: #8892b0;
            font-size: 0.9rem;
        }
        .info-row .value {
            font-weight: 500;
            font-size: 0.9rem;
        }

        /* å¾½ç«  */
        .badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .badge.success { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .badge.warning { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .badge.danger { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .badge.info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }

        /* æŒ‰é’® */
        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }
        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }
        .btn-success {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #fff;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }

        /* æ—¥å¿—åŒºåŸŸ */
        .log-area {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            max-height: 120px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
        }
        .log-entry {
            padding: 2px 0;
            color: #8892b0;
        }
        .log-entry.success { color: #4ade80; }
        .log-entry.error { color: #ef4444; }

        /* WebRTC æ’­æ”¾å™¨ */
        .player-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }
        .video-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.7);
            color: #8892b0;
            font-size: 1.2rem;
        }
        .video-overlay.hidden {
            display: none;
        }
        .video-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .video-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .stat-item {
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 8px;
        }
        .stat-item .stat-label {
            color: #8892b0;
            font-size: 0.75rem;
            margin-bottom: 3px;
        }
        .stat-item .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* WebRTC è¿æ¥çŠ¶æ€ */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        .connection-status.connected { background: rgba(74, 222, 128, 0.1); }
        .connection-status.connecting { background: rgba(251, 191, 36, 0.1); }
        .connection-status.disconnected { background: rgba(239, 68, 68, 0.1); }

        /* é¡µè„š */
        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            color: #8892b0;
            font-size: 0.85rem;
        }

        /* å“åº”å¼ */
        @media (max-width: 640px) {
            .container { padding: 10px; }
            header h1 { font-size: 1.4rem; }
            .tabs { flex-direction: column; }
            .tab-btn { padding: 10px; }
            .cards { grid-template-columns: 1fr; }
            .btn-group { flex-direction: column; }
            .video-controls { flex-direction: column; align-items: stretch; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ¥ AIPC</h1>
            <p>RV1106 è¾¹ç¼˜ AI ç›¸æœº</p>
        </header>

        <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('dashboard')">
                ğŸ“Š æ§åˆ¶é¢æ¿
            </button>
            <button class="tab-btn" onclick="switchTab('player')">
                â–¶ï¸ å®æ—¶é¢„è§ˆ
            </button>
            <button class="tab-btn" onclick="switchTab('webrtc')">
                ğŸŒ WebRTC
            </button>
        </div>

        <!-- çŠ¶æ€æ  -->
        <div class="status-bar">
            <div class="status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">æ­£åœ¨è¿æ¥...</span>
            </div>
            <span id="lastUpdate" style="color: #8892b0; font-size: 0.85rem;">-</span>
        </div>

        <!-- æ§åˆ¶é¢æ¿æ ‡ç­¾é¡µ -->
        <div id="tab-dashboard" class="tab-content active">
            <div class="cards">
                <!-- RTSP å¡ç‰‡ -->
                <div class="card">
                    <h2><span class="icon">ğŸ“¡</span> RTSP æ¨æµ</h2>
                    <div class="info-row">
                        <span class="label">æœåŠ¡çŠ¶æ€</span>
                        <span class="badge" id="rtspStatus">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">URL</span>
                        <span class="value" id="rtspUrl" style="font-size: 0.8rem;">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">å‘é€å¸§æ•°</span>
                        <span class="value" id="rtspFrames">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">å‘é€æ•°æ®</span>
                        <span class="value" id="rtspBytes">-</span>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-success" id="btnRtspStart" onclick="rtspStart()">â–¶ å¯åŠ¨æœåŠ¡</button>
                        <button class="btn btn-danger" id="btnRtspStop" onclick="rtspStop()">â¹ åœæ­¢æœåŠ¡</button>
                    </div>
                </div>

                <!-- WebRTC å¡ç‰‡ -->
                <div class="card">
                    <h2><span class="icon">ğŸŒ</span> WebRTC</h2>
                    <div class="info-row">
                        <span class="label">æœåŠ¡çŠ¶æ€</span>
                        <span class="badge" id="webrtcStatus">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">å¯ç”¨</span>
                        <span class="value" id="webrtcEnabled">-</span>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-success" id="btnWebrtcStart" onclick="webrtcServiceStart()">â–¶ å¯åŠ¨æœåŠ¡</button>
                        <button class="btn btn-danger" id="btnWebrtcStop" onclick="webrtcServiceStop()">â¹ åœæ­¢æœåŠ¡</button>
                    </div>
                </div>

                <!-- å½•åˆ¶å¡ç‰‡ -->
                <div class="card">
                    <h2><span class="icon">âº</span> è§†é¢‘å½•åˆ¶</h2>
                    <div class="info-row">
                        <span class="label">çŠ¶æ€</span>
                        <span class="badge" id="recordStatus">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">è¾“å‡ºç›®å½•</span>
                        <span class="value" id="recordDir" style="font-size: 0.8rem;">-</span>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-success" id="btnRecordStart" onclick="recordStart()">âº å¼€å§‹å½•åˆ¶</button>
                        <button class="btn btn-danger" id="btnRecordStop" onclick="recordStop()">â¹ åœæ­¢å½•åˆ¶</button>
                    </div>
                </div>

                <!-- æ—¥å¿—å¡ç‰‡ -->
                <div class="card">
                    <h2><span class="icon">ğŸ“‹</span> æ“ä½œæ—¥å¿—</h2>
                    <div class="log-area" id="logArea">
                        <div class="log-entry">ç­‰å¾…æ“ä½œ...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å®æ—¶é¢„è§ˆæ ‡ç­¾é¡µ (WebSocket H.264) -->
        <div id="tab-player" class="tab-content">
            <div class="player-container">
                <!-- è§†é¢‘åŒºåŸŸ -->
                <div class="video-wrapper">
                    <video id="wsVideo" autoplay playsinline muted></video>
                    <div class="video-overlay" id="wsVideoOverlay">
                        <span>ç‚¹å‡»"è¿æ¥"å¼€å§‹é¢„è§ˆ</span>
                    </div>
                </div>

                <!-- æ§åˆ¶æŒ‰é’® -->
                <div class="video-controls">
                    <div class="connection-status disconnected" id="wsConnStatus">
                        <div class="status-dot offline" id="wsConnDot"></div>
                        <span id="wsConnText">æœªè¿æ¥</span>
                    </div>
                    <button class="btn btn-success" id="btnWsConnect" onclick="wsConnect()">â–¶ è¿æ¥</button>
                    <button class="btn btn-danger" id="btnWsDisconnect" onclick="wsDisconnect()" disabled>â¹ æ–­å¼€</button>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="chkWsAutoReconnect">
                        <span style="color: #8892b0; font-size: 0.85rem;">è‡ªåŠ¨é‡è¿</span>
                    </label>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="video-stats">
                    <div class="stat-item">
                        <div class="stat-label">åˆ†è¾¨ç‡</div>
                        <div class="stat-value" id="wsStatResolution">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å¸§ç‡</div>
                        <div class="stat-value" id="wsStatFps">- fps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ç ç‡</div>
                        <div class="stat-value" id="wsStatBitrate">- kbps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å·²æ¥æ”¶</div>
                        <div class="stat-value" id="wsStatReceived">0 B</div>
                    </div>
                </div>

                <!-- æç¤ºä¿¡æ¯ -->
                <div class="card" style="margin-top: 15px; padding: 15px;">
                    <p style="color: #8892b0; font-size: 0.85rem; margin: 0;">
                        ğŸ’¡ æç¤ºï¼šWebSocket H.264 ç›´æ¥ä¼ è¾“æ¨¡å¼ï¼Œä½å»¶è¿Ÿ (~100ms)ã€‚æµè§ˆå™¨ç«¯ä½¿ç”¨ jMuxer è¿›è¡Œè§£ç æ’­æ”¾ã€‚
                    </p>
                </div>
            </div>
        </div>

        <!-- WebRTC æ ‡ç­¾é¡µ (åŸæœ‰åŠŸèƒ½) -->
        <div id="tab-webrtc" class="tab-content">
            <div class="player-container">
                <!-- è§†é¢‘åŒºåŸŸ -->
                <div class="video-wrapper">
                    <video id="remoteVideo" autoplay playsinline muted></video>
                    <div class="video-overlay" id="videoOverlay">
                        <span>ç‚¹å‡»"è¿æ¥"å¼€å§‹é¢„è§ˆ</span>
                    </div>
                </div>

                <!-- æ§åˆ¶æŒ‰é’® -->
                <div class="video-controls">
                    <div class="connection-status disconnected" id="connStatus">
                        <div class="status-dot offline" id="connDot"></div>
                        <span id="connText">æœªè¿æ¥</span>
                    </div>
                    <button class="btn btn-success" id="btnConnect" onclick="webrtcConnect()">â–¶ è¿æ¥</button>
                    <button class="btn btn-danger" id="btnDisconnect" onclick="webrtcDisconnect()" disabled>â¹ æ–­å¼€</button>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="chkAutoReconnect">
                        <span style="color: #8892b0; font-size: 0.85rem;">è‡ªåŠ¨é‡è¿</span>
                    </label>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="video-stats">
                    <div class="stat-item">
                        <div class="stat-label">åˆ†è¾¨ç‡</div>
                        <div class="stat-value" id="statResolution">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å¸§ç‡</div>
                        <div class="stat-value" id="statFps">- fps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ç ç‡</div>
                        <div class="stat-value" id="statBitrate">- kbps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å·²æ¥æ”¶</div>
                        <div class="stat-value" id="statReceived">0 B</div>
                    </div>
                </div>

                <!-- æç¤ºä¿¡æ¯ -->
                <div class="card" style="margin-top: 15px; padding: 15px;">
                    <p style="color: #8892b0; font-size: 0.85rem; margin: 0;">
                        ğŸ’¡ æç¤ºï¼šWebRTC ä½å»¶è¿Ÿç›´è¿æ¨¡å¼ã€‚å¦‚æœè¿æ¥å¤±è´¥ï¼Œè¯·ç¡®ä¿è®¾å¤‡å’Œæµè§ˆå™¨åœ¨åŒä¸€å±€åŸŸç½‘å†…ã€‚
                    </p>
                </div>
            </div>
        </div>

        <div class="footer">
            Powered by RV1106 & libdatachannel
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jmuxer@2.0.5/dist/jmuxer.min.js"></script>
    <script>
        // =====================================================================
        // å…¨å±€å˜é‡
        // =====================================================================
        const API_BASE = '';
        let updateTimer = null;
        let statsTimer = null;
        
        // WebRTC ç›¸å…³
        let peerConnection = null;
        let lastBytesReceived = 0;
        let lastStatsTime = 0;
        let pendingIceCandidates = [];  // ç¼“å†²å¾…å‘é€çš„ ICE å€™é€‰
        let answerSent = false;         // Answer æ˜¯å¦å·²å‘é€
        
        // WebSocket H.264 ç›¸å…³
        let wsConnection = null;
        let jmuxer = null;
        let wsBytesReceived = 0;
        let wsLastBytesReceived = 0;
        let wsLastStatsTime = 0;
        let wsFrameCount = 0;
        let wsLastFrameCount = 0;
        let wsStatsTimer = null;

        // =====================================================================
        // å·¥å…·å‡½æ•°
        // =====================================================================
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function addLog(message, type = '') {
            const logArea = document.getElementById('logArea');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
            while (logArea.children.length > 50) {
                logArea.removeChild(logArea.firstChild);
            }
        }

        // =====================================================================
        // æ ‡ç­¾é¡µåˆ‡æ¢
        // =====================================================================
        function switchTab(tabId) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // æ›´æ–°å†…å®¹æ˜¾ç¤º
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById('tab-' + tabId).classList.add('active');
        }

        // =====================================================================
        // API è°ƒç”¨
        // =====================================================================
        async function apiCall(method, endpoint, body = null) {
            try {
                const options = {
                    method: method,
                    headers: { 'Content-Type': 'application/json' }
                };
                if (body) options.body = JSON.stringify(body);
                const response = await fetch(API_BASE + endpoint, options);
                return await response.json();
            } catch (error) {
                console.error('API Error:', error);
                return { success: false, message: error.message };
            }
        }

        // =====================================================================
        // çŠ¶æ€æ›´æ–°
        // =====================================================================
        async function updateStatus() {
            try {
                const status = await apiCall('GET', '/api/status');
                
                if (status.success) {
                    document.getElementById('statusDot').classList.remove('offline');
                    document.getElementById('statusText').textContent = 'å·²è¿æ¥';
                    
                    const data = status.data;
                    
                    // RTSP çŠ¶æ€
                    if (data.rtsp) {
                        const el = document.getElementById('rtspStatus');
                        if (data.rtsp.running) {
                            el.textContent = 'è¿è¡Œä¸­';
                            el.className = 'badge success';
                        } else if (data.rtsp.valid) {
                            el.textContent = 'å·²åœæ­¢';
                            el.className = 'badge warning';
                        } else {
                            el.textContent = 'æœªå¯ç”¨';
                            el.className = 'badge info';
                        }
                    }
                    
                    // WebRTC çŠ¶æ€
                    if (data.webrtc) {
                        const el = document.getElementById('webrtcStatus');
                        document.getElementById('webrtcEnabled').textContent = data.webrtc.enabled ? 'æ˜¯' : 'å¦';
                        if (data.webrtc.running) {
                            el.textContent = 'è¿è¡Œä¸­';
                            el.className = 'badge success';
                        } else {
                            el.textContent = 'å·²åœæ­¢';
                            el.className = 'badge warning';
                        }
                    }
                    
                    // å½•åˆ¶çŠ¶æ€
                    if (data.recording) {
                        const el = document.getElementById('recordStatus');
                        document.getElementById('recordDir').textContent = data.recording.output_dir || '-';
                        if (data.recording.active) {
                            el.textContent = 'å½•åˆ¶ä¸­';
                            el.className = 'badge danger';
                        } else {
                            el.textContent = 'å¾…æœº';
                            el.className = 'badge info';
                        }
                    }
                } else {
                    document.getElementById('statusDot').classList.add('offline');
                    document.getElementById('statusText').textContent = 'è¿æ¥å¤±è´¥';
                }

                // RTSP è¯¦ç»†çŠ¶æ€
                const rtspDetail = await apiCall('GET', '/api/rtsp/status');
                if (rtspDetail.success && rtspDetail.data) {
                    document.getElementById('rtspUrl').textContent = rtspDetail.data.url || '-';
                    document.getElementById('rtspFrames').textContent = rtspDetail.data.frames_sent || 0;
                    document.getElementById('rtspBytes').textContent = formatBytes(rtspDetail.data.bytes_sent || 0);
                }

                document.getElementById('lastUpdate').textContent = 'æ›´æ–°: ' + new Date().toLocaleTimeString();
            } catch (error) {
                document.getElementById('statusDot').classList.add('offline');
                document.getElementById('statusText').textContent = 'è¿æ¥é”™è¯¯';
            }
        }

        // =====================================================================
        // æ§åˆ¶é¢æ¿æ“ä½œ
        // =====================================================================
        async function rtspStart() {
            addLog('æ­£åœ¨å¯åŠ¨ RTSP æœåŠ¡...');
            const result = await apiCall('POST', '/api/rtsp/start');
            if (result.success) {
                addLog('RTSP æœåŠ¡å¯åŠ¨æˆåŠŸ', 'success');
            } else {
                addLog('RTSP æœåŠ¡å¯åŠ¨å¤±è´¥: ' + result.message, 'error');
            }
            updateStatus();
        }

        async function rtspStop() {
            addLog('æ­£åœ¨åœæ­¢ RTSP æœåŠ¡...');
            const result = await apiCall('POST', '/api/rtsp/stop');
            if (result.success) {
                addLog('RTSP æœåŠ¡å·²åœæ­¢', 'success');
            } else {
                addLog('RTSP æœåŠ¡åœæ­¢å¤±è´¥: ' + result.message, 'error');
            }
            updateStatus();
        }

        async function webrtcServiceStart() {
            addLog('æ­£åœ¨å¯åŠ¨ WebRTC æœåŠ¡...');
            const result = await apiCall('POST', '/api/webrtc/start');
            if (result.success) {
                addLog('WebRTC æœåŠ¡å¯åŠ¨æˆåŠŸ', 'success');
            } else {
                addLog('WebRTC æœåŠ¡å¯åŠ¨å¤±è´¥: ' + result.message, 'error');
            }
            updateStatus();
        }

        async function webrtcServiceStop() {
            addLog('æ­£åœ¨åœæ­¢ WebRTC æœåŠ¡...');
            const result = await apiCall('POST', '/api/webrtc/stop');
            if (result.success) {
                addLog('WebRTC æœåŠ¡å·²åœæ­¢', 'success');
            } else {
                addLog('WebRTC æœåŠ¡åœæ­¢å¤±è´¥: ' + result.message, 'error');
            }
            updateStatus();
        }

        async function recordStart() {
            addLog('æ­£åœ¨å¼€å§‹å½•åˆ¶...');
            const result = await apiCall('POST', '/api/record/start');
            if (result.success) {
                addLog('å½•åˆ¶å·²å¼€å§‹', 'success');
            } else {
                addLog('å½•åˆ¶å¯åŠ¨å¤±è´¥: ' + result.message, 'error');
            }
            updateStatus();
        }

        async function recordStop() {
            addLog('æ­£åœ¨åœæ­¢å½•åˆ¶...');
            const result = await apiCall('POST', '/api/record/stop');
            if (result.success) {
                addLog('å½•åˆ¶å·²åœæ­¢', 'success');
            } else {
                addLog('å½•åˆ¶åœæ­¢å¤±è´¥: ' + result.message, 'error');
            }
            updateStatus();
        }

        // =====================================================================
        // WebRTC æ’­æ”¾å™¨
        // =====================================================================
        function updateConnectionStatus(state) {
            const status = document.getElementById('connStatus');
            const dot = document.getElementById('connDot');
            const text = document.getElementById('connText');
            
            status.className = 'connection-status ' + state;
            
            switch(state) {
                case 'connected':
                    dot.classList.remove('offline');
                    text.textContent = 'å·²è¿æ¥';
                    document.getElementById('videoOverlay').classList.add('hidden');
                    break;
                case 'connecting':
                    dot.classList.add('offline');
                    text.textContent = 'è¿æ¥ä¸­...';
                    break;
                case 'disconnected':
                default:
                    dot.classList.add('offline');
                    text.textContent = 'æœªè¿æ¥';
                    document.getElementById('videoOverlay').classList.remove('hidden');
                    document.getElementById('videoOverlay').querySelector('span').textContent = 'ç‚¹å‡»"è¿æ¥"å¼€å§‹é¢„è§ˆ';
            }
        }

        async function webrtcConnect() {
            if (peerConnection) {
                webrtcDisconnect();
            }

            updateConnectionStatus('connecting');
            document.getElementById('btnConnect').disabled = true;
            document.getElementById('btnDisconnect').disabled = false;
            addLog('æ­£åœ¨å»ºç«‹ WebRTC è¿æ¥...');
            
            // é‡ç½®çŠ¶æ€
            pendingIceCandidates = [];
            answerSent = false;

            try {
                // è·å– WebRTC offer
                const offerResp = await apiCall('POST', '/api/webrtc/offer');
                if (!offerResp.success) {
                    throw new Error(offerResp.message || 'è·å– offer å¤±è´¥');
                }

                const { sdp, ice_servers } = offerResp.data;

                // åˆ›å»º PeerConnection
                const config = {
                    iceServers: ice_servers || [{ urls: 'stun:stun.l.google.com:19302' }]
                };
                peerConnection = new RTCPeerConnection(config);

                // å¤„ç† ICE candidate - ç¼“å†²ç›´åˆ° Answer å‘é€æˆåŠŸ
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        if (answerSent) {
                            // Answer å·²å‘é€ï¼Œç›´æ¥å‘é€ ICE å€™é€‰
                            await apiCall('POST', '/api/webrtc/ice', {
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            });
                        } else {
                            // ç¼“å†² ICE å€™é€‰
                            pendingIceCandidates.push({
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            });
                        }
                    }
                };

                // å¤„ç†è¿æ¥çŠ¶æ€å˜åŒ–
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                    switch (peerConnection.connectionState) {
                        case 'connected':
                            updateConnectionStatus('connected');
                            addLog('WebRTC è¿æ¥æˆåŠŸ', 'success');
                            startStatsUpdate();
                            break;
                        case 'disconnected':
                        case 'failed':
                        case 'closed':
                            updateConnectionStatus('disconnected');
                            stopStatsUpdate();
                            if (document.getElementById('chkAutoReconnect').checked && 
                                peerConnection.connectionState !== 'closed') {
                                addLog('è¿æ¥æ–­å¼€ï¼Œå°è¯•é‡è¿...', 'error');
                                setTimeout(webrtcConnect, 2000);
                            }
                            break;
                    }
                };

                // å¤„ç†è¿œç¨‹æµ
                peerConnection.ontrack = (event) => {
                    console.log('Received track:', event.track.kind);
                    const video = document.getElementById('remoteVideo');
                    if (event.streams && event.streams[0]) {
                        video.srcObject = event.streams[0];
                    }
                };

                // è®¾ç½®è¿œç¨‹æè¿°
                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: sdp
                }));

                // åˆ›å»ºå¹¶è®¾ç½®æœ¬åœ°æè¿°
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // å‘é€ answer
                const answerResp = await apiCall('POST', '/api/webrtc/answer', {
                    sdp: answer.sdp
                });

                if (!answerResp.success) {
                    throw new Error(answerResp.message || 'å‘é€ answer å¤±è´¥');
                }
                
                // Answer å‘é€æˆåŠŸï¼Œå‘é€ç¼“å†²çš„ ICE å€™é€‰
                answerSent = true;
                for (const candidate of pendingIceCandidates) {
                    await apiCall('POST', '/api/webrtc/ice', candidate);
                }
                pendingIceCandidates = [];

            } catch (error) {
                console.error('WebRTC connect error:', error);
                addLog('WebRTC è¿æ¥å¤±è´¥: ' + error.message, 'error');
                updateConnectionStatus('disconnected');
                document.getElementById('btnConnect').disabled = false;
                document.getElementById('btnDisconnect').disabled = true;
            }
        }

        function webrtcDisconnect() {
            stopStatsUpdate();
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            const video = document.getElementById('remoteVideo');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }

            updateConnectionStatus('disconnected');
            document.getElementById('btnConnect').disabled = false;
            document.getElementById('btnDisconnect').disabled = true;
            
            // é‡ç½®ç»Ÿè®¡
            document.getElementById('statResolution').textContent = '-';
            document.getElementById('statFps').textContent = '- fps';
            document.getElementById('statBitrate').textContent = '- kbps';
            document.getElementById('statReceived').textContent = '0 B';
            
            addLog('WebRTC å·²æ–­å¼€');
        }

        // ç»Ÿè®¡ä¿¡æ¯æ›´æ–°
        function startStatsUpdate() {
            lastBytesReceived = 0;
            lastStatsTime = Date.now();
            statsTimer = setInterval(updateVideoStats, 1000);
        }

        function stopStatsUpdate() {
            if (statsTimer) {
                clearInterval(statsTimer);
                statsTimer = null;
            }
        }

        async function updateVideoStats() {
            if (!peerConnection) return;

            try {
                const stats = await peerConnection.getStats();
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        // åˆ†è¾¨ç‡
                        if (report.frameWidth && report.frameHeight) {
                            document.getElementById('statResolution').textContent = 
                                `${report.frameWidth}x${report.frameHeight}`;
                        }
                        
                        // å¸§ç‡
                        if (report.framesPerSecond) {
                            document.getElementById('statFps').textContent = 
                                report.framesPerSecond.toFixed(1) + ' fps';
                        }
                        
                        // ç ç‡
                        const now = Date.now();
                        const bytesReceived = report.bytesReceived || 0;
                        if (lastStatsTime > 0) {
                            const timeDiff = (now - lastStatsTime) / 1000;
                            const bytesDiff = bytesReceived - lastBytesReceived;
                            const bitrate = (bytesDiff * 8 / timeDiff / 1000).toFixed(0);
                            document.getElementById('statBitrate').textContent = bitrate + ' kbps';
                        }
                        lastBytesReceived = bytesReceived;
                        lastStatsTime = now;
                        
                        // å·²æ¥æ”¶
                        document.getElementById('statReceived').textContent = formatBytes(bytesReceived);
                    }
                });
            } catch (e) {
                console.error('Stats error:', e);
            }
        }

        // =====================================================================
        // WebSocket H.264 æ’­æ”¾å™¨
        // =====================================================================
        function updateWsConnectionStatus(state) {
            const status = document.getElementById('wsConnStatus');
            const dot = document.getElementById('wsConnDot');
            const text = document.getElementById('wsConnText');
            
            status.className = 'connection-status ' + state;
            
            switch(state) {
                case 'connected':
                    dot.classList.remove('offline');
                    text.textContent = 'å·²è¿æ¥';
                    document.getElementById('wsVideoOverlay').classList.add('hidden');
                    break;
                case 'connecting':
                    dot.classList.add('offline');
                    text.textContent = 'è¿æ¥ä¸­...';
                    break;
                case 'disconnected':
                default:
                    dot.classList.add('offline');
                    text.textContent = 'æœªè¿æ¥';
                    document.getElementById('wsVideoOverlay').classList.remove('hidden');
                    document.getElementById('wsVideoOverlay').querySelector('span').textContent = 'ç‚¹å‡»"è¿æ¥"å¼€å§‹é¢„è§ˆ';
            }
        }

        function wsConnect() {
            if (wsConnection) {
                wsDisconnect();
            }

            updateWsConnectionStatus('connecting');
            document.getElementById('btnWsConnect').disabled = true;
            document.getElementById('btnWsDisconnect').disabled = false;
            addLog('æ­£åœ¨å»ºç«‹ WebSocket è¿æ¥...');
            
            // é‡ç½®ç»Ÿè®¡
            wsBytesReceived = 0;
            wsFrameCount = 0;

            try {
                // åˆ›å»º jMuxer å®ä¾‹ - æ³¨æ„ï¼šå¿…é¡»åœ¨ video å…ƒç´ å¯è§æ—¶åˆ›å»º
                const videoElement = document.getElementById('wsVideo');
                if (!videoElement) {
                    addLog('è§†é¢‘å…ƒç´ ä¸å­˜åœ¨', 'error');
                    return;
                }
                
                jmuxer = new JMuxer({
                    node: 'wsVideo',
                    mode: 'video',
                    flushingTime: 1,  // ç«‹å³åˆ·æ–°
                    fps: 30,
                    clearBuffer: true,  // æ¸…é™¤æ—§ç¼“å­˜
                    debug: true,  // å¼€å¯è°ƒè¯•çœ‹é”™è¯¯
                    onReady: function() {
                        console.log('jMuxer ready');
                        addLog('jMuxer è§£ç å™¨å°±ç»ª', 'success');
                    },
                    onError: function(err) {
                        console.error('jMuxer error:', err);
                        // ä¸è¦å› ä¸ºè§£ç é”™è¯¯å°±æ–­å¼€è¿æ¥
                    }
                });

                // å»ºç«‹ WebSocket è¿æ¥
                const wsUrl = `ws://${window.location.hostname}:8082`;
                wsConnection = new WebSocket(wsUrl);
                wsConnection.binaryType = 'arraybuffer';

                wsConnection.onopen = () => {
                    updateWsConnectionStatus('connected');
                    addLog('WebSocket è¿æ¥æˆåŠŸ', 'success');
                    startWsStatsUpdate();
                };

                wsConnection.onclose = (event) => {
                    updateWsConnectionStatus('disconnected');
                    stopWsStatsUpdate();
                    addLog(`WebSocket è¿æ¥å·²å…³é—­, code=${event.code}, reason=${event.reason || '(æ— )'}`);
                    console.log('WebSocket close event:', event);
                    
                    if (document.getElementById('chkWsAutoReconnect').checked) {
                        addLog('å°è¯•é‡è¿...');
                        setTimeout(wsConnect, 2000);
                    } else {
                        document.getElementById('btnWsConnect').disabled = false;
                        document.getElementById('btnWsDisconnect').disabled = true;
                    }
                };

                wsConnection.onerror = (err) => {
                    console.error('WebSocket error:', err);
                    addLog('WebSocket é”™è¯¯', 'error');
                };

                wsConnection.onmessage = (event) => {
                    if (event.data instanceof ArrayBuffer) {
                        const data = new Uint8Array(event.data);
                        wsBytesReceived += data.length;
                        wsFrameCount++;
                        
                        // è°ƒè¯•ï¼šæ‰“å°å‰å‡ å­—èŠ‚çœ‹NALç±»å‹
                        if (wsFrameCount <= 5) {
                            let hex = '';
                            for (let i = 0; i < Math.min(10, data.length); i++) {
                                hex += data[i].toString(16).padStart(2, '0') + ' ';
                            }
                            console.log(`Frame ${wsFrameCount}, size=${data.length}, start: ${hex}`);
                        }
                        
                        // å–‚ç»™ jMuxer
                        if (jmuxer) {
                            try {
                                jmuxer.feed({
                                    video: data
                                });
                            } catch (e) {
                                console.error('Feed error:', e);
                            }
                        }
                    }
                };

            } catch (error) {
                console.error('WebSocket connect error:', error);
                addLog('WebSocket è¿æ¥å¤±è´¥: ' + error.message, 'error');
                updateWsConnectionStatus('disconnected');
                document.getElementById('btnWsConnect').disabled = false;
                document.getElementById('btnWsDisconnect').disabled = true;
            }
        }

        function wsDisconnect() {
            stopWsStatsUpdate();
            
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }

            if (jmuxer) {
                jmuxer.destroy();
                jmuxer = null;
            }

            updateWsConnectionStatus('disconnected');
            document.getElementById('btnWsConnect').disabled = false;
            document.getElementById('btnWsDisconnect').disabled = true;
            
            // é‡ç½®ç»Ÿè®¡
            document.getElementById('wsStatResolution').textContent = '-';
            document.getElementById('wsStatFps').textContent = '- fps';
            document.getElementById('wsStatBitrate').textContent = '- kbps';
            document.getElementById('wsStatReceived').textContent = '0 B';
            
            addLog('WebSocket å·²æ–­å¼€');
        }

        function startWsStatsUpdate() {
            wsLastBytesReceived = 0;
            wsLastFrameCount = 0;
            wsLastStatsTime = Date.now();
            wsStatsTimer = setInterval(updateWsVideoStats, 1000);
        }

        function stopWsStatsUpdate() {
            if (wsStatsTimer) {
                clearInterval(wsStatsTimer);
                wsStatsTimer = null;
            }
        }

        function updateWsVideoStats() {
            const video = document.getElementById('wsVideo');
            
            // åˆ†è¾¨ç‡
            if (video.videoWidth && video.videoHeight) {
                document.getElementById('wsStatResolution').textContent = 
                    `${video.videoWidth}x${video.videoHeight}`;
            }
            
            // å¸§ç‡ & ç ç‡
            const now = Date.now();
            const timeDiff = (now - wsLastStatsTime) / 1000;
            
            if (timeDiff > 0) {
                // å¸§ç‡
                const framesDiff = wsFrameCount - wsLastFrameCount;
                const fps = framesDiff / timeDiff;
                document.getElementById('wsStatFps').textContent = fps.toFixed(1) + ' fps';
                
                // ç ç‡
                const bytesDiff = wsBytesReceived - wsLastBytesReceived;
                const bitrate = (bytesDiff * 8 / timeDiff / 1000).toFixed(0);
                document.getElementById('wsStatBitrate').textContent = bitrate + ' kbps';
            }
            
            wsLastBytesReceived = wsBytesReceived;
            wsLastFrameCount = wsFrameCount;
            wsLastStatsTime = now;
            
            // å·²æ¥æ”¶
            document.getElementById('wsStatReceived').textContent = formatBytes(wsBytesReceived);
        }

        // =====================================================================
        // åˆå§‹åŒ–
        // =====================================================================
        document.addEventListener('DOMContentLoaded', () => {
            addLog('æ§åˆ¶é¢æ¿å·²åŠ è½½');
            updateStatus();
            updateTimer = setInterval(updateStatus, 3000);
        });
    </script>
</body>
</html>
